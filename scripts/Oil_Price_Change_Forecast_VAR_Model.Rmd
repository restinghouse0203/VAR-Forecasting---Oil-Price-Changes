---
title: "Oil Supply, Demand, and Prices Forecasting: Structural VAR Model (1973–2007)"
author: "Tony Au"
date: "2025-09-10"
output:
  pdf_document:
    latex_engine: xelatex
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
This report analyzes the dynamics of global crude oil supply, demand, and prices using a Vector Autoregression (VAR) model. The variables considered are the percent change in global crude oil production (`dprod`), changes in freight rates deflated by US CPI (`rea`), and the real price of oil (`rpo`). The goal is to forecast oil price changes and understand the impact of structural shocks on macroeconomic indicators like real GDP and inflation.

```{r eval=TRUE, warning=FALSE,message=FALSE}
rm(list=ls())
# install.packages("vars")  # Install once if needed
# install.packages("roll")
suppressPackageStartupMessages(library(quantmod))  # Data download (FRED) and xts helpers
suppressPackageStartupMessages(library(ggpubr))    # Plot arrangements
suppressPackageStartupMessages(library(lubridate)) # Date utilities
suppressPackageStartupMessages(library(dynlm))     # Time-series OLS with L() lag operator
suppressPackageStartupMessages(library(strucchange)) # Stability tests (CUSUM)
suppressPackageStartupMessages(library(forecast))  # fanchart and forecasting utils
library(tidyverse)  # ggplot2 and data wrangling
library(tseries)    # Time-series tests
library(vars)       # VAR estimation, IRF, FEVD, diagnostics
library(readxl)     # Read Excel input (oildata.xlsx)
```

# 3-variable VAR for (oil supply, global demand, oil price)
This section builds the monthly dataset, converts to time-series objects, and visualizes the series. We treat dprod as supply, rea as global demand proxy, and rpo as real oil price. Monthly frequency is set to 12 for consistent lagging and diagnostics.
```{r eval=TRUE, warning=FALSE,message=FALSE}
# Load the data
data.oil <- read_xlsx("oildata.xlsx")

# dprod: percent change in global crude oil production
# rea: changes in freight rates deflated by US CPI (in logs)
# rpo: real price of oil (in logs)

data.oil <- ts(data.oil[,2:4], start = c(1973,2), end = c(2007,12), frequency = 12 )
head(data.oil,3)
tail(data.oil,3)
```

```{r eval=TRUE, warning=FALSE,message=FALSE}

data.oil <- as.xts(data.oil)

# Plot the series
autoplot(data.oil) + xlab("") + theme_bw()
```

## Step 1. VAR lag selection
We choose the VAR lag length by minimizing information criteria (AIC, HQ, SC, FPE). Longer lags capture richer dynamics but reduce degrees of freedom.
```{r eval=TRUE, message=FALSE, warning=FALSE}
var.info <- VARselect(data.oil, lag.max = 24, type = "const")  # IC-based lag selection up to 24
var.info$selection  # Shows optimal lags by AIC, HQ, SC, FPE
```

## Step 2. Estimate VAR(24) as in the class example 
The VAR(p) system is Yt = c + A1Yt−1 + … + ApYt−p + εt, with εt ~ N(0, Σ). We estimate with OLS equation-by-equation, which is efficient under identical regressors.
```{r eval=TRUE, warning=FALSE,message=FALSE}
nlag    <- 24   # Chosen lag order (can compare with var.info results)
var.oil <- VAR(data.oil, p = nlag, type = "const")    # Estimate VAR(p) with constant
summary(var.oil)  # Obtain coefficients, SEs, R^2 per equation
```

## Granger causality test
Granger causality tests whether lagged X improves prediction of Y beyond Y’s own lags. Bivariate tests use pairs; multivariate tests condition on the full system.
```{r eval=TRUE, warning=FALSE,message=FALSE}
# Bivariate Granger Causality
grangertest(data.oil$rea,data.oil$dprod,24)  # Does dprod → rea?
grangertest(data.oil$rpo,data.oil$dprod,24)  # Does dprod → rpo?
grangertest(data.oil$dprod,data.oil$rea,24)  # Does rea → dprod?
grangertest(data.oil$rpo,data.oil$rea,24)    # Does rea → rpo?
grangertest(data.oil$rea,data.oil$rpo,24)    # Does rpo → rea?
grangertest(data.oil$dprod,data.oil$rpo,24)  # Does rpo → dprod?

# Multivariate Granger Causality (conditions on the whole VAR)
causality(var.oil, cause = "dprod", vcov. = sandwich)  # H0: lags of dprod don't help explain others
causality(var.oil, cause = "rea",   vcov. = sandwich)
causality(var.oil, cause = "rpo",   vcov. = sandwich)
```
Global demand (rea) helps predict future oil production (dprod) at conventional levels (p≈0.004), while other bivariate links are weak or insignificant. However, once we condition on the full VAR (multivariate Granger tests), all three variables—production, demand, and the real oil price—contain predictive information for the others (p<1%), indicating meaningful feedback among them. Instantaneous-causality p‑values are not significant, so there’s no strong evidence of same‑period effects after controlling for lags, which is consistent with using a recursive (Cholesky) identification. 

In plain language: demand, supply, and prices evolve jointly, each helping to forecast the others over time, with demand’s predictive role most evident in the pairwise tests.

## Forcase Error Variance decomposition (FEVD)
Forecast Error Variance Decomposition attributes the h‑step forecast error variance of each variable to shocks from all variables under the identification scheme.
```{r eval=TRUE, warning=FALSE,message=FALSE}
var.oil.fevd <- fevd(var.oil, n.ahead = 24)   # Share of forecast error variance by shock at horizons
plot(var.oil.fevd)

# remark: dprod shocks explain only small fractions of "rea" and "rpo"
```

# Impulse responses function (IRF)
IRFs trace the effect of a one‑unit structural shock over time. With recursive (Cholesky) identification, the variable order implies contemporaneous causal ordering.
```{r eval=TRUE, warning=FALSE,message=FALSE}
# Impulse responses: recursive order = default (p,u,r)
irf.dprod <- irf(var.oil, n.ahead = 24, 
                 ci = 0.95, 
                 impulse = "dprod", 
                 response = c("dprod", "rea", "rpo"))  # Responses to a supply shock
head(irf.dprod$irf)
plot(irf.dprod)  # Bands reflect 95% CI
```

```{r eval=TRUE, warning=FALSE,message=FALSE}

irf.rea  <- irf(var.oil, n.ahead = 24, 
                ci = 0.95, 
                impulse = "rea", 
                response = c("dprod", "rea", "rpo"))
plot(irf.rea)
```

```{r eval=TRUE, warning=FALSE,message=FALSE}
irf.rpo  <- irf(var.oil, n.ahead = 24, 
                 ci = 0.95, 
                 impulse = "rpo", 
                 response = c("dprod", "rea", "rpo"))
plot(irf.rpo)
```

## Diagnostic tests
We check stability (CUSUM), serial correlation (Portmanteau), conditional heteroskedasticity (ARCH), and normality to validate VAR assumptions.
```{r eval=TRUE, warning=FALSE,message=FALSE}
# Stability test
var.oil.break <- stability(var.oil, type = "OLS-CUSUM")  # Detects parameter instability
plot(var.oil.break)
```

```{r eval=TRUE, warning=FALSE,message=FALSE}
# Residual test
resid1 <- serial.test(var.oil, lags.pt = 24)  # Portmanteau test for autocorrelation
resid1
```

```{r eval=TRUE, warning=FALSE,message=FALSE}
# arch test
arch1 <- arch.test(var.oil, lags.single = 24, lags.multi = 24, multivariate.only = F)
arch1

arch2 <- arch.test(var.oil, lags.single = 24, lags.multi = 24, multivariate.only = T)
arch2
```

```{r eval=TRUE, warning=FALSE,message=FALSE}
# Normality test
norm1 <- normality.test(var.oil, multivariate.only = F)  # Jarque-Bera type
norm1

norm2 <- normality.test(var.oil, multivariate.only = T)
norm2
```

# forecast
We produce multi‑step VAR forecasts and visualize uncertainty via fan charts (approximate ±kσ intervals).
```{r eval=TRUE, warning=FALSE,message=FALSE}
h <- 36   # forecast horizon

var.oil.pred <- predict(var.oil, n.ahead = h, ci = 0.95) # Multi-step VAR forecast 
#x11(); par(mai=rep(0.5, 4)); fanchart(var.oil.pred)  #open new graph window; plot margin=0.5in all sides
fanchart(var.oil.pred)
# example to compare: https://fred.stlouisfed.org/series/POILBREUSDM
```

## Obtain the structural shocks
Structural shocks u are recovered from reduced‑form residuals ε via ε = B0 u, where B0 is lower‑triangular under recursive identification. We recover B0 from contemporaneous IRFs.
```{r eval=TRUE, warning=FALSE,message=FALSE}
# Save the reduced-form residuals
n <- length(data.oil[,1])
# nlag is lag order

# Extract the residuals
res <- residuals(var.oil)   # sample size - lag order
head(res)
tail(res)
```

```{r eval=TRUE, warning=FALSE,message=FALSE}

res <- xts(res,order.by = index(data.oil)[-seq(1,nlag)])

# Define the structural shocks from the recursive form's irf function
# Mapping between reduced-form shocks and standardized structural shocks:

# e1 = sig1*u1
# e2 = a*u1 + sig2*u2
# e3 = b*u1 + c*u2 + sig3*u3

# The structural VAR: (Lecture note p.33)
# y1 = lags + e1 = lags + sig1*u1
# y2 = lags + e2 = lags + a*u1 + sig2*u2
# y3 = lags + e3 = lags + b*u1 + c*u2 + sig3*u3

# So the contemporaneous IRF is given by {sig1,sig2,sig3,a,b,c}:
#  sig1 is the irf of u1 to y1; sig2 is irf of u2 to y2; sig3 is irf of u3 to y3
#  a is the irf of u1 to y2;  b is the irf of u1 to y3;  c is the irf of u2 to y3

sig1 <- irf.dprod$irf$dprod[1,1]  # contemporaneous IRF of y1 to u1 (σ1)
a    <- irf.dprod$irf$dprod[1,2]  # contemporaneous effect of u1 on y2 (a)
b    <- irf.dprod$irf$dprod[1,3]  # contemporaneous effect of u1 on y3 (b)

sig2 <- irf.rea$irf$rea[1,2]      # σ2
c    <- irf.rea$irf$rea[1,3]      # contemporaneous effect of u2 on y3 (c)

sig3 <- irf.rpo$irf$rpo[1,3]      # σ3

# Structural shocks: standardized (solve ε = B0 u for u)
u1 <- res[,1]/sig1                        # u1 = ε1/σ1
u2 <- (res[,2] - a*u1)/sig2               # u2 = (ε2 − a u1)/σ2
u3 <- (res[,3] - b*u1 - c*u2)/sig3        # u3 = (ε3 − b u1 − c u2)/σ3

u <- cbind(u1,u2,u3)
autoplot(u) + xlab("") + theme_bw()
```

* Alternative way to recover structural shocks using Cholesky decomposition
Direct Cholesky: Σ = PP′ with P lower‑triangular. Then u = P^{-1} ε. We adjust degrees of freedom when estimating Σ.
```{r eval=TRUE, warning=FALSE,message=FALSE}
N <- dim(res)[1]
# n is the total sample size n = N+24

res.var_cov_mat <-  var(res)*(N-1)/(N-25*3)  # DoF-adjusted Σ̂ for reduced-form shocks
#variance-covariance matrix of reduced-form shocks (omega)
#Note: The "var()" function computes sample variance which by defaults assumes the degree of freedom is N-1. In our VAR model, the number of parameters is 25*3 (24 lag order and 1 constant term for each equation). So the degree of freedom is N-25*3.

res.chol_mat <- t(chol(res.var_cov_mat)) #lower-triangular matrix of Cholesky decomposition
                                         #t() means transpose of a matrix

# Comparison
res.chol_mat%*%t(res.chol_mat);res.var_cov_mat # Verify Σ̂ ≈ P P¸′

u_chol <- solve(res.chol_mat) %*% t(res) #use "solve" to compute the inverse of lower-triangular matrix

u_chol <- t(u_chol)# Conform dimensions (time × shocks)

#Note: The structural shocks obtained by Cholesky decomposition (u_chol) are close to those structural shocks implied by recursive form's irf function (u). The slight differences between u_chol and u are due to the numerical errors when we compute the inverse of lower-triangular matrix.
data <- xts(u_chol[,1:3], order.by = index(res), unique = FALSE, tzone = "")
autoplot(data) + xlab("") + theme_bw()
```

# Implications of structural shocks for macro aggregates
We aggregate monthly shocks to quarter averages and run distributed‑lag OLS to estimate cumulative effects on real GDP and inflation.
```{r eval=TRUE, warning=FALSE,message=FALSE}
qlag <- 12   # number of lagged shocks in the OLS regression

# define quarterly average of structural shocks
ep.q <- endpoints(u,'quarters') # Quarter endpoints in xts index
u.q  <- period.apply(u, INDEX=ep.q, FUN = mean, na.rm=TRUE) # quarter average at quarter-end
# period.apply(): Apply Function Over Specified Interval

head(u.q)
tail(u.q)
```

# Subset the real GDP series: 1975 - 2007
We fetch GDPC1 from FRED, convert to quarterly, align dates, and keep 1975–2007 for comparability with oil data.
```{r eval=TRUE, warning=FALSE,message=FALSE}
# Load Real GDP Data from FRED
# Fetch US Real GDP data (GDPC1) from FRED
getSymbols("GDPC1", src = "FRED", from = "1970-01-01", to = "2010-12-31")
y <- GDPC1
# Convert to quarterly data if needed and subset to 1975-2007
y <- to.quarterly(y, name = "rgdp") # OHLC format; 4th column is Close

rgdp <- y["1975/2007"][,4] # Keep 'Close' column as level for quarter-end
names(rgdp) <- "rgdp"
head(rgdp)
tail(rgdp)
```

```{r eval=TRUE, warning=FALSE,message=FALSE}
index(u.q) <- index(rgdp)  # use quarter-start to denote timing
data.q <- cbind(rgdp, u.q)
data.q <- as.ts(data.q)    # package dynlm works only with "ts" objects
head(data.q)
tail(data.q)
```

# OLS distributed-lags regression
The regression rgdp_t = α + Σ_{k=0}^{12} β_k shock_{t−k} + e_t. Cumulative IR = Σ_{j=0}^{h} β_j.
```{r eval=TRUE, warning=FALSE,message=FALSE}
# Distributed-lags regression: Predict current values of a dependent variable based on both the current values and lagged values of an explanatory variable 

eq1.y <- dynlm(rgdp ~ L(dprod,0:qlag), data = data.q)  # rgdp on supply shock lags
eq2.y <- dynlm(rgdp ~ L(rea,0:qlag),   data = data.q)  # rgdp on global demand shock lags
eq3.y <- dynlm(rgdp ~ L(rpo,0:qlag),   data = data.q)  # rgdp on oil-specific demand shock lags

summary(eq1.y)       # first coefficient is intercept
```

# Define cumulative impulse responses and confidence intervals
We compute cumulative sums of β̂ and their standard errors using the cumulative variance formula var(Σ β̂) = 1′ V 1 with cumulative summation.
```{r eval=TRUE, warning=FALSE,message=FALSE}
# Cumulative impulse responses: Integrating the impulse response over time

b1  <- cumsum(coef(eq1.y)[2:(qlag+2)])   # The coefficients from t to t-12 (\nabla_h = Σ_{j=0}^{h} β̂_j (exclude intercept))
v1  <- vcov(eq1.y)[2:(qlag+2),2:(qlag+2)] # V = Var(β̂_{0..12}; vcov(): Variance-Covariance Matrix
```

```{r eval=TRUE, warning=FALSE,message=FALSE}
# Remark: var(a+b+c) = var(a)+var(b)+var(c)+2cov(a,b)+2cov(b,c)+2cov(a,c)
# This is the cumsum of the rows and columns or the variance-covariance matrix

# Example of using apply() with cumsum
# m1 <- matrix(C<-(1:10),nrow=5, ncol=6)
# apply(m1, 2, cumsum)

vb1 <- apply(apply(v1, 2, cumsum), 1, cumsum) # Cumulative variance of cumulative sums
sb1 <- sqrt(diag(vb1))   # SE of the cumsum of slope coefficients

# To verify, we may compare
all.equal(sum(sum(v1[1:3,1:3])), vb1[3,3]) # Simple check for h=3 case
```

```{r eval=TRUE, warning=FALSE,message=FALSE}
# Plot cumulative impulse responses with +/- SE or 2SE bands
plot1 <- ggplot(as.data.frame(b1), aes(x = 0:qlag, y = b1)) + 
  geom_ribbon(aes(ymin = b1 - 2*sb1, ymax = b1 + 2*sb1),
              fill = "lightgrey") + 
  geom_ribbon(aes(ymin = b1 - sb1, ymax = b1 + sb1),
              fill = "grey") + 
  geom_path(size = 0.6) +    # set the size of the time series line plot 
  geom_hline(yintercept = 0, linetype = 4, colour = "red") +
  xlab("") + 
  ylab("Real GDP") +
  ggtitle("Crude oil supply shock")

```

```{r eval=TRUE, warning=FALSE,message=FALSE}
# similarly, we define rgdp's responses to "rea" and "rpo"
b2  <- cumsum(coef(eq2.y)[2:(qlag+2)])
v2  <- vcov(eq2.y)[2:(qlag+2),2:(qlag+2)]
vb2 <- apply(apply(v2, 2, cumsum), 1, cumsum)
sb2 <- sqrt(diag(vb2))   # SE of the cumsum of slope coefficients

b3  <- cumsum(coef(eq3.y)[2:(qlag+2)])
v3  <- vcov(eq3.y)[2:(qlag+2),2:(qlag+2)]
vb3 <- apply(apply(v3, 2, cumsum), 1, cumsum)
sb3 <- sqrt(diag(vb3))   # SE of the cumsum of slope coefficients
```

```{r eval=TRUE, warning=FALSE,message=FALSE}
# plot cumulative impulse responses with +/- SE or 2SE bands
plot2 <- ggplot(as.data.frame(b2), aes(x = 0:qlag, y = b2)) + 
  geom_ribbon(aes(ymin = b2 - 2*sb2, ymax = b2 + 2*sb2),
              fill = "lightgrey") + 
  geom_ribbon(aes(ymin = b2 - sb2, ymax = b2 + sb2),
              fill = "grey") + 
  geom_path(size = 0.6) +    # set the size of the time series line plot 
  geom_hline(yintercept = 0, linetype = 4, colour = "red") +
  xlab("") + 
  ylab("Real GDP") +
  ggtitle("Aggregate demand shock")

plot3 <- ggplot(as.data.frame(b3), aes(x = 0:qlag, y = b3)) + 
  geom_ribbon(aes(ymin = b3 - 2*sb3, ymax = b3 + 2*sb3),
              fill = "lightgrey") + 
  geom_ribbon(aes(ymin = b3 - sb3, ymax = b3 + sb3),
              fill = "grey") + 
  geom_path(size = 0.6) +    # set the size of the time series line plot 
  geom_hline(yintercept = 0, linetype = 4, colour = "red") +
  xlab("") + 
  ylab("Real GDP") +
  ggtitle("Oil-market specific demand shock")

ggarrange(plot1,plot2,plot3, ncol = 1)
```

## Implications to quarterly inflation
We construct monthly PCE inflation as 100·Δlog(PCEPI), aggregate to quarters, align with shocks, and estimate distributed‑lag effects on PCE inflation.
```{r eval=TRUE, warning=FALSE,message=FALSE}
# Load PCE Inflation Data from FRED

# Fetch US PCE Price Index data (PCEPI) from FRED
getSymbols("PCEPI", src = "FRED", from = "1970-01-01", to = "2010-12-31")
p <- PCEPI
# Convert to monthly percent change to represent inflation rate
p <- diff(log(p)) * 100 # π_t = 100·[log(P_t) − log(P_{t−1})]
# Convert to xts object if needed for endpoints function
p <- as.xts(p)

ep.q <- endpoints(p,'quarters')
p.q  <- period.apply(p, INDEX=ep.q, FUN = mean, na.rm=TRUE) # quarter average at quarter-end

# subset the inflation series: 1975 - 2007
pce <- p.q["1975/2007"]
names(pce) <- "pce"

# use quarter-start to denote timing
index(pce) <- index(rgdp)  
index(u.q) <- index(rgdp)

data.q <- cbind(pce, u.q)
data.q <- as.ts(data.q)    # package dynlm works only with "ts" objects

# OLS distributed-lags regression
eq1.y <- dynlm(pce ~ L(dprod,0:qlag), data = data.q)  # Inflation on supply shock lags
eq2.y <- dynlm(pce ~ L(rea,0:qlag),   data = data.q)  # Inflation on aggregate demand shock lags
eq3.y <- dynlm(pce ~ L(rpo,0:qlag),   data = data.q)  # Inflation on oil-specific demand shock lags


b4  <- cumsum(coef(eq1.y)[2:(qlag+2)])
v4  <- vcov(eq1.y)[2:(qlag+2),2:(qlag+2)]
vb4 <- apply(apply(v4, 2, cumsum), 1, cumsum)
sb4 <- sqrt(diag(vb4))   # SE of the cumsum of slope coefficients

b5  <- cumsum(coef(eq2.y)[2:(qlag+2)])
v5  <- vcov(eq2.y)[2:(qlag+2),2:(qlag+2)]
vb5 <- apply(apply(v5, 2, cumsum), 1, cumsum)
sb5 <- sqrt(diag(vb5))   # SE of the cumsum of slope coefficients

b6  <- cumsum(coef(eq3.y)[2:(qlag+2)])
v6  <- vcov(eq3.y)[2:(qlag+2),2:(qlag+2)]
vb6 <- apply(apply(v6, 2, cumsum), 1, cumsum)
sb6 <- sqrt(diag(vb6))   # SE of the cumsum of slope coefficients
```

* Plot cumulative impulse responses with +/- SE or 2SE bands
```{r eval=TRUE, warning=FALSE,message=FALSE}

plot4 <- ggplot(as.data.frame(b4), aes(x = 0:qlag, y = b4)) + 
  geom_ribbon(aes(ymin = b4 - 2*sb4, ymax = b4 + 2*sb4),
              fill = "lightgrey") + 
  geom_ribbon(aes(ymin = b4 - sb4, ymax = b4 + sb4),
              fill = "grey") + 
  geom_path(size = 0.6) +    # set the size of the time series line plot 
  geom_hline(yintercept = 0, linetype = 4, colour = "red") +
  xlab("") + 
  ylab("PCE Inflation") +
  ggtitle("Crude oil supply shock")

plot5 <- ggplot(as.data.frame(b5), aes(x = 0:qlag, y = b5)) + 
  geom_ribbon(aes(ymin = b5 - 2*sb5, ymax = b5 + 2*sb5),
              fill = "lightgrey") + 
  geom_ribbon(aes(ymin = b5 - sb5, ymax = b5 + sb5),
              fill = "grey") + 
  geom_path(size = 0.6) +    # set the size of the time series line plot 
  geom_hline(yintercept = 0, linetype = 4, colour = "red") +
  xlab("") + 
  ylab("PCE Inflation") +
  ggtitle("Aggregate demand shock")

plot6 <- ggplot(as.data.frame(b6), aes(x = 0:qlag, y = b6)) + 
  geom_ribbon(aes(ymin = b6 - 2*sb6, ymax = b6 + 2*sb6),
              fill = "lightgrey") + 
  geom_ribbon(aes(ymin = b6 - sb6, ymax = b6 + sb6),
              fill = "grey") + 
  geom_path(size = 0.6) +    # set the size of the time series line plot 
  geom_hline(yintercept = 0, linetype = 4, colour = "red") +
  xlab("") + 
  ylab("PCE inflation") +
  ggtitle("Oil-market specific demand shock")

ggarrange(plot1, plot4, plot2, plot5, plot3, plot6, nrow = 3, ncol = 2)

```

# Conclusion
The results indicate that aggregate demand shocks are the dominant driver of macro outcomes: they lift both real GDP and PCE inflation strongly and persistently. Oil‑market–specific demand shocks, by contrast, are stagflationary—reducing real GDP while pushing inflation higher. Pure oil supply shocks (increased production) have comparatively modest and less persistent effects on both variables, with responses often near zero initially and remaining small relative to demand‑driven movements.
Further work should extend the sample through the present, test alternative identification schemes (different Cholesky orderings, sign restrictions, or external instruments for oil supply), evaluate robustness to lag length and stability/breaks (e.g., 1986, 2008, 2014), consider richer models (SVAR, BVAR, or time‑varying parameter VAR), incorporate additional controls (monetary policy, financial conditions, global activity indices), and perform out‑of‑sample forecast evaluation against benchmarks; examining core PCE inflation and alternative activity measures would also strengthen the conclusions.
